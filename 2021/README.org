#+title: 2021 Advent of code solutions
#+author: Matthias Paulmier

My advent of code solutions for 2021. These are writtent in *emacs-lisp* and use
a lot of the =cl-*= facilities.

* Utils

Extract the contents of a file the emacs way.

#+begin_src emacs-lisp
  (defun mp/file-content (filename)
    (with-temp-buffer
      (insert-file-contents filename)
      (string-trim
       (buffer-substring-no-properties
        (point-min)
        (point-max)))))
#+end_src

A macro that gives a nice environment to define solutions to the challenges. It
will probably change a bit as the days progress and I realise it is missing
some things.

#+begin_src emacs-lisp
  (defmacro defsolution (day parser &rest part1 part2)
    "Utility macro that preloads the input of the DAY.

    PARSER is a function that takes a string argument corresponding to the DAY's input.

    Returns the result of PART1 and PART2 in a list"
    `(let* ((url (concat (concat "https://adventofcode.com/2021/day/" (int-to-string ,day)) "/input"))
            (lexical-binding t)
            (filename (concat "inputs/" (int-to-string ,day)))
            (cookie (mp/file-content "../session-cookie.txt"))
            (url-request-extra-headers
             (list (cons "Cookie" cookie))))
       (if (not (file-exists-p filename))
           (url-copy-file url filename))

       ;; Load data into input list
       (let ((input (funcall ,parser (mp/file-content filename))))
         (list ,@part1 ,@part2))))
#+end_src

* Day 1

#+begin_src emacs-lisp
  (defun count-depth-increases (depths)
    (let ((prev (car depths)))
      (cl-loop for depth in (cdr depths)
               if (> depth prev) count depth
               do (setq prev depth))))

  (defun day1-parser (content)
    (mapcar #'string-to-number
            (split-string content "\n" t)))

  (defsolution 1 #'day1-parser
    ;; part 1
    (count-depth-increases input)
    ;; part 2
    (progn
      (let ((sums (cl-loop for (a b c) on input
                           while (not (null c))
                           collect (+ a b c))))
        (count-depth-increases sums))))
#+end_src

* Day 2

#+begin_src emacs-lisp
  (defun day2-parser (content)
    (split-string content nil t))

  (defsolution 2 #'day2-parser
    ;; Part 1
    (let ((pos 0)
          (depth 0))
      (cl-loop for (dir amount) on input by #'cddr do
               (let ((x (string-to-number amount)))
                 (cond
                  ((equal dir "forward") (setf pos (+ pos x)))
                  ((equal dir "down") (setf depth (+ depth x)))
                  ((equal dir "up") (setf depth (- depth x))))))
      (* pos depth))
    ;; Part2
    (let ((pos 0)
          (depth 0)
          (aim 0))
      (cl-loop for (dir amount) on input by #'cddr do
               (let ((x (string-to-number amount)))
                 (cond
                  ((equal dir "forward") (progn
                                           (setf depth (+ depth (* aim x)))
                                           (setf pos (+ pos x))))
                  ((equal dir "down") (setf aim (+ aim x)))
                  ((equal dir "up") (setf aim (- aim x))))))
      (* pos depth)))
#+end_src
* Day 3

#+begin_src emacs-lisp
  (defun day3-parser (content)
    "Change CONTENT to list of lists of bits"
    (mapcar #'(lambda (x)
                (cl-map 'list #'(lambda (c) (- c 48)) x))
            (split-string content)))

  (defun compute-occurences (seq1 seq2)
    "For each bit in SEQ2 add 1 if 1 or -1 if 0 to the element in
  SEQ1 at the same position. SEQ1 and SEQ2 must be of equal length"
    (cl-loop for x in seq2
             for i from 0 do
             (if (eq 0 x)
                 (cl-incf (nth i seq1) -1)
               (cl-incf (nth i seq1) 1)))
    seq1)

  (defun list-of-bits-from-occurences (seq &optional revert)
    "Take SEQ the result of reducing the input with
  COMPUTE-OCCURENCES and transform it into a list of bits. If
  REVERT is non nil, 1 means least common bit at this position
  otherwise it is the most common."
    (let ((comparator (if revert #'< #'>)))
      (mapcar #'(lambda (x) (if (funcall comparator x 0) 1 0)) seq)))

  (defun list-of-bits-to-number (seq)
    (string-to-number (cl-concatenate 'string (mapcar #'(lambda (x) (+ 48 x)) seq)) 2))

  (defun find-number-from-bits (seq bits)
    "SEQ is a list of list of numbers. Go through eash position and
  remove all lists that don't contain the bits in BITS"
    (let ((seq-copy (cl-copy-list seq)))
      (cl-loop for bit in bits
               for i from 0
               while (> (length seq-copy) 1) do
               (setf seq-copy (cl-remove-if-not #'(lambda (x) (eq bit (nth i x))) seq-copy)))
      (car seq-copy)))

  (defmacro let-part (&rest body)
    "Both part1 and part2 use the same variables"
    `(let* ((occurences (cl-reduce #'compute-occurences
                                   input
                                   :initial-value (make-list (length (car input)) 0)))
            (gamma (list-of-bits-from-occurences occurences))
            (epsilon (list-of-bits-from-occurences occurences t)))
       ,@body))

  (defsolution 3 #'day3-parser
    (let-part
     (* (list-of-bits-to-number gamma) (list-of-bits-to-number epsilon)))
    (let-part
     (let ((co2 (find-number-from-bits input gamma))
           (oxygen (find-number-from-bits input epsilon)))
       (* (list-of-bits-to-number co2) (list-of-bits-to-number oxygen)))))
#+end_src
