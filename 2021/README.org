#+title: 2021 Advent of code solutions
#+author: Matthias Paulmier

* Utils

#+begin_src emacs-lisp
  (defun mp/file-content (filename)
    (with-temp-buffer
      (insert-file-contents filename)
      (string-trim
       (buffer-substring-no-properties
        (point-min)
        (point-max)))))

  (defmacro defsolution (day parser &rest part1 part2)
    "Utility macro that preloads the input of the DAY.

    PARSER is a function that takes a string argument corresponding to the DAY's input.

    Returns the result of PART1 and PART2 in a list"
    `(let* ((url (concat (concat "https://adventofcode.com/2021/day/" (int-to-string ,day)) "/input"))
            (lexical-binding t)
            (filename (concat "inputs/" (int-to-string ,day)))
            (cookie (mp/file-content "../session-cookie.txt"))
            (url-request-extra-headers
             (list (cons "Cookie" cookie))))
       (if (not (file-exists-p filename))
           (url-copy-file url filename))

       ;; Load data into input list
       (let ((input (funcall ,parser (mp/file-content filename))))
         (list ,@part1 ,@part2))))
#+end_src

* Day 1

#+begin_src emacs-lisp
  (defun count-depth-increases (depths)
    (let ((prev (car depths)))
      (cl-loop for depth in (cdr depths)
               if (> depth prev) count depth
               do (setq prev depth))))

  (defun day1-parser (content)
    (mapcar #'string-to-number
            (split-string content "\n" t)))

  (defsolution 1 #'day1-parser
    ;; part 1
    (count-depth-increases input)
    ;; part 2
    (progn
      (let ((sums (cl-loop for (a b c) on input
                           while (not (null c))
                           collect (+ a b c))))
        (count-depth-increases sums))))
#+end_src

* Day 2

#+begin_src emacs-lisp
  (defun day2-parser (content)
    (split-string content nil t))

  (defsolution 2 #'day2-parser
    ;; Part 1
    (let ((pos 0)
          (depth 0))
      (cl-loop for (dir amount) on input by #'cddr do
               (let ((x (string-to-number amount)))
                 (cond
                  ((equal dir "forward") (setf pos (+ pos x)))
                  ((equal dir "down") (setf depth (+ depth x)))
                  ((equal dir "up") (setf depth (- depth x))))))
      (* pos depth))
    ;; Part2
    (let ((pos 0)
          (depth 0)
          (aim 0))
      (cl-loop for (dir amount) on input by #'cddr do
               (let ((x (string-to-number amount)))
                 (cond
                  ((equal dir "forward") (progn
                                           (setf depth (+ depth (* aim x)))
                                           (setf pos (+ pos x))))
                  ((equal dir "down") (setf aim (+ aim x)))
                  ((equal dir "up") (setf aim (- aim x))))))
      (* pos depth)))
#+end_src
